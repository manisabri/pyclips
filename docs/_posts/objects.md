Classes and Objects\[pyclips-objects\]
======================================

As previously stated in the introduction, provides classes and objects
to access CLIPS “*entities*”. It could be preferable to refer to
counterparts “living” in the CLIPS subsystem as *entities* than as
*objects*, because it is common practice in OOP to give the name of
“*objects*” to class instances: since CLIPS has its own object oriented
structure (in fact there are *classes* in CLIPS, and therefore also
*instances* of these), calling these structures simply *objects* may
generate confusion.

Entities in CLIPS are generated by *constructs*, one for each type of
entity. In Python, the common way to create something is to instance an
for a certain . So it seemed straightforward to make a class for each of
these entities, and to substitute the constructs used in CLIPS to create
entities with *factory functions*. These functions are defined at module
level, and have names of the type where is the type of entity that has
to be created. The only exception for this are objects, which are
created in several ways from s or ions.

There is another way to create entities in the CLIPS subsystem, that is
directly using the function with a full CLIPS construct as string
argument. However, this function does not return anything to the caller,
so the created entity has to be sought after creation to obtain a
reference.

The functions and the function return objects of proper types (whose
detailed list is given below) which shadow the corresponding entities in
the CLIPS space.

Wrapper Classes\[pyclips-cl-wrapper\]
-------------------------------------

There are some simple classes that deserve a special mention in the
module, used to represent in Python namespace the basic types in CLIPS.
These *wrappers* are used to differentiate values that CLIPS returns
from other values that live in the Python space. However these classes
are equivalent to their Python counterparts, and there is no need to
pass objects converted to these classes to the module functions. Here is
a list containing the class names and their equivalents in Python:

<span>l|l|l</span><span>class</span><span>Class</span><span>Type</span><span>Python
Equivalent</span>

A special object named is defined, and is equivalent to in comparisons
and slot assignments. It is provided to make code more readable in such
situations. It has to be noticed that also evaluates to in boolean
tests: this also yields for the explicit and definitions[^1].

Template\[pyclips-cl-Template\]
-------------------------------

s are used to build objects, that is, they provide a systematic way to
construct s sharing a common pattern, and the only way to define s that
have named (the equivalent of record *fields* or *structure members* in
other programming languages).

<span>Template</span>

This represents a copy of a construct in the CLIPS subsystem, and not a
true entity. More than one object in Python can refer to the same entity
in the CLIPS subsystem.

<span>BuildFact</span> Build a object using this without asserting it.
The created can be modified and the asserted using its method.

\[property\]<span>Deletable</span> Read-only property to verify if this
can be deleted from the CLIPS subsystem.

<span>InitialFact</span> Return initial in list created using this .

\[property\]<span>Module</span> Read-only property to retrieve the CLIPS
name of the where the is defined.

\[property\]<span>Name</span> Read-only property returning the name in
CLIPS of this . The name identifies this entity in the CLIPS subsystem,
and has nothing to do with the name given to the corresponding object in
Python.

<span>Next</span> Return next[^2] in the list of all s. is returned at
the end of the list.

<span>NextFact</span><span>fact</span> Return next in list created using
this , using the supplied as offset.

<span>PPForm</span> Return the *pretty-print form* of this .
*Pretty-print forms* are often the code necessary to build a construct
in CLIPS, formatted in a way that makes it quite readable. The result of
the method can be used as the argument for the top level function to
rebuild the construct once the has been cleared[^3].

<span>Remove</span> Remove the entity corresponding to this from the
CLIPS subsystem. This does not remove the corresponding Python object
that has instead to be deleted via the statement or garbage collected.

\[property\]<span>Slots</span> information. This is itself an object,
having many methods, and deserves a special explaination.

<span>AllowedValues</span><span>name</span> Return a list of allowed
values for specified by .

<span>Cardinality</span><span>name</span> Return *cardinality* for
specified by .

<span>DefaultValue</span><span>name</span> Return *cardinality* for
specified by .

<span>Exists</span><span>name</span> Return if specified by exists,
otherwise.

<span>HasDefault</span><span>name</span> Return one of the following
values: if the default value is set to , when the default value is
static and when it is dynamically generated (eg. ).

<span>IsMultifileld</span><span>name</span> Return if specified by is a
value, otherwise.

<span>IsSinglefield</span><span>name</span> Return if specified by is a
single field value, otherwise.

<span>Names</span> Return the list of names.

<span>Range</span><span>name</span> Return *numerical range information*
for specified by .

<span>Types</span><span>name</span> Return names of *primitive types*
for specified by .

\[property\]<span>Watch</span> Read-only property to verify if this is
being watched.

The name of this entity in CLIPS is also returned by the string coercion
function. The *factory function* for s is , which has been discussed
above.

Fact\[pyclips-cl-Fact\]
-----------------------

s are one of the main entities in CLIPS, since it is whether a exists or
not of that drives the subsystem in the decision to fire or not certain
s. s, as seen above, can be created in several ways, that is either by
directly asserting sentences in string form, or by building them first
from s and then asserting them.

<span>Fact</span>

This represents a copy of a fact definition in the CLIPS subsystem, and
not a true fact entity. More than one Fact objects in Python can refer
to the same fact entity in the CLIPS subsystem. Many CLIPS functions
return a object, but most objects obtained from CLIPS are
*read-only*[^4]. Read-only s cannot be reasserted or modified in , and
are provided for “informational” purposes only.

The argument can be a string with the same format of the function seen
in the previous chapter: in this case the fact is created and asserted.
Otherwise the argument can be a object, and in this case the resulting
can be modified and then asserted via the member function.

<span>Assert</span> Assert this . Only s that have been constructed from
s can be ed using this method: read-only s can only be inspected with
the other methods/properties.

<span>AssignSlotDefaults</span> Assign default values to of this .

<span>CleanPPForm</span> Return only the second part of this s
*pretty-print form* – which can be used to build the itself as described
above.

<span>Exists</span> Is if this has been asserted (and never retracted),
otherwise.

\[property\]<span>ImpliedSlots</span> The list of all *implied* for this
.

\[property\]<span>Index</span> Read-only property returning the index in
CLIPS of this . As for other entities the is a unique identifier, as is
the for s.

<span>Next</span> Return next in the list of all s. This list is not
based on s, but global to the CLIPS subsystem.

<span>PPForm</span> Return the *pretty-print form* of this . In this
case, only the second part of the returned string (the one between
parentheses) can be used to build the via the function[^5].

<span>PPrint</span> Print the to the standard output. When is set to
(the default), slots containing the default values are omitted.

\[property\]<span>Relation</span> Return only the name of the *relation*
that identifies this [^6] as a .

<span>Retract</span> Retract this : in other words, remove the
corresponding entity from the CLIPS subsystem. As in seen above, this
does not delete the corresponding Python object. is returned at the end
of the list.

\[property\]<span>Slots</span> Dictionary of . This member *behaves*
like a , but is not related to such objects. In fact, the values of are
accessible using a -like syntax (square brackets), but not all the
members of are implemented.

Please note that s have slightly different methods than classes
representing other entities in CLIPS: an instance of is created using
the module-level function, and removed using the member function: this
syntax, closer to the original CLIPS form, was seen as the preferred
method instead of using a name such as for creation and a member because
of the particular nature of related to other types of entity.

Here is an example of usage of and objects:

    >>> import clips
    >>> clips.Reset()
    >>> t0 = clips.BuildTemplate("person", """
        (slot name (type STRING))
        (slot age (type INTEGER))
    """, "template for a person")
    >>> print t0.PPForm()
    (deftemplate MAIN::person "template for a person"
       (slot name (type STRING))
       (slot age (type INTEGER)))

    >>> f1 = clips.Fact(t0)
    >>> f1_slotkeys = f1.Slots.keys()
    >>> print f1_slotkeys
    <Multifield [<Symbol 'name'>, <Symbol 'age'>]>
    >>> f1.Slots['name'] = "Grace"
    >>> f1.Slots['age'] = 24
    >>> print f1.PPForm()
    f-0     (person (name "Grace") (age 24))
    >>> clips.PrintFacts()
    f-0     (initial-fact)
    >>> f1.Assert()
    <Fact 'f-1': fact object at 0x00E0CB10>
    >>> print f1.Exists()
    True
    >>> clips.PrintFacts()
    f-0     (initial-fact)
    f-1     (person (name "Grace") (age 24))
    For a total of 2 facts.
    >>> f1.Retract()
    >>> print f1.Exists()
    False
    >>> clips.PrintFacts()
    f-0     (initial-fact)
    For a total of 1 fact.

Please note that slot names are implemented as s, and the list of is
returned as a . Also note that the , that has been constructed from a
(and not yet ed) object and then modified using the property, can be ed
while other s built from construct strings cannot.

Deffacts\[pyclips-cl-Deffacts\]
-------------------------------

A is used to modify the “initial structure” of a CLIPS environment, by
allowing some s to be ed by default each time the function is called.

<span>Deffacts</span>

This represents a copy of a construct in the CLIPS subsystem, and not a
true entity. More than one object in Python can refer to the same entity
in the CLIPS subsystem.

\[property\]<span>Deletable</span> Read-only property to verify if this
can be deleted.

\[property\]<span>Module</span> Read-only property to retrieve the CLIPS
name of the where the is defined.

\[property\]<span>Name</span> Read-only property returning the name in
CLIPS of this .

<span>Next</span> Return next in the list of all . is returned at the
end of the list.

<span>PPForm</span> Return the *pretty-print form* of this .

<span>Remove</span> Remove the entity corresponding to this from the
CLIPS subsystem.

The name of this entity in CLIPS is also returned by the string coercion
function. The *factory function* for is , which has been discussed
above.

Rule\[pyclips-cl-Rule\]
-----------------------

The construct defines rules to be activated and then *fired* whenever
particular conditions are met. This construct is in fact the counterpart
of the construct in CLIPS. Normally conditions that fire s are s ed
during a session.

<span>Rule</span>

This represents a copy of a construct in the CLIPS subsystem, and not a
true entity. More than one object in Python can refer to the same entity
in the CLIPS subsystem.

\[property\]<span>Breakpoint</span> Set or remove a breakpoint from this
.

\[property\]<span>Deletable</span> Read-only property to verify if this
can be deleted.

\[property\]<span>Module</span> Read-only property to retrieve the CLIPS
name of the where the is defined.

\[property\]<span>Name</span> Read-only property returning the name in
CLIPS of this .

<span>Next</span> Return next in the list of all s. is returned at the
end of the list.

<span>PPForm</span> Return the *pretty-print form* of this .

<span>PrintMatches</span> Print partial matches of this to standard
output.

<span>Refresh</span> Refresh this .

<span>Remove</span> Remove the entity corresponding to this from the
CLIPS subsystem.

\[property\]<span>WatchActivations</span> Set or reset debugging of
*activations* for this .

\[property\]<span>WatchFirings</span> Set or reset debugging of
*firings* for this .

The name of this entity in CLIPS is also returned by the string coercion
function. The *factory function* for s is , which has been discussed
above.

An example – derived from the ones present in the standard CLIPS
documentation – may be useful here:

    >>> clips.Reset()
    >>> r1 = clips.BuildRule("duck-rule", "(duck)",
                             "(assert (quack))", "The Duck rule")
    >>> print r1.PPForm()
    (defrule MAIN::duck-rule "The Duck rule"
       (duck)
       =>
       (assert (quack)))

    >>> clips.PrintFacts()
    f-0     (initial-fact)
    For a total of 1 fact.
    >>> clips.PrintRules()
    MAIN:
    duck-rule
    >>> f1 = clips.Assert("(duck)")
    >>> clips.PrintAgenda()
    MAIN:
       0      duck-rule: f-1
    For a total of 1 activation.
    >>> clips.PrintFacts()
    f-0     (initial-fact)
    f-1     (duck)
    For a total of 2 facts.
    >>> clips.Run()
    >>> clips.PrintFacts()
    f-0     (initial-fact)
    f-1     (duck)
    f-2     (quack)
    For a total of 3 facts.

Activation\[pyclips-cl-Activation\]
-----------------------------------

s are only returned by the CLIPS subsystem, and cannot be created – thus
there is no *factory function* for these objects. CLIPS provides objects
to keep the program flow under control.

<span>Activation</span>

This represents a copy of an object in the CLIPS subsystem, and not a
true entity. More than one object in Python can refer to the same entity
in the CLIPS subsystem.

\[property\]<span>Name</span> Retrieve name.

<span>Next</span> Return next in the list of all s. is returned at the
end of the list.

<span>PPForm</span> Return the *pretty-print form* of .

\[property\]<span>Salience</span> Retrieve *salience*[^7].

<span>Remove</span> Remove this from CLIPS.

The name of this entity in CLIPS is also returned by the string coercion
function.

Global\[pyclips-cl-Global\]
---------------------------

objects represent *global variables* in CLIPS, which are normally built
using the construct. To define a new variable the function must be used,
which returns a new object.

<span>Global</span>

A object represents a copy of a construct in the CLIPS subsystem, and
not a true entity. More than one object in Python can refer to the same
entity in the CLIPS subsystem.

\[property\]<span>Deletable</span> Verify if this can be deleted.

\[property\]<span>Module</span> Read-only property to retrieve the CLIPS
name of the where the is defined.

\[property\]<span>Name</span> Retrieve name. The returned value is a
containing the name of the global variable in the CLIPS subsystem.

<span>Next</span> Return next in the list of all global variables. is
returned at the end of the list.

<span>PPForm</span> Return the *pretty-print* form of .

<span>Remove</span> Remove this from CLIPS subsystem.

\[property\]<span>Value</span> Set or retrieve value. The returned value
can be of many types, depending on the type of value contained in the
corresponding CLIPS global variable.

<span>ValueForm</span> Return a “*printed*” form of value. The *printed*
form is the one that would be used in CLIPS to represent the variable
itself.

\[property\]<span>Watch</span> Set or retrieve debug status.

Some examples follow to show the use of objects:

    >>> g_x = clips.BuildGlobal("x", 15)

This is equivalent to the CLIPS declaration:

    CLIPS> (defglobal ?*x* = 15)

Some of the methods are illustrated here:

    >>> g_x
    <Global 'x': defglobal object at 0x00E09960>
    >>> print g_x
    x
    >>> g_x.Value
    <Integer 15>
    >>> print g_x.Value
    15
    >>> print g_x.ValueForm()
    ?*x* = 15

The name of this entity in CLIPS is also returned by the string coercion
function.

Function\[pyclips-cl-Function\]
-------------------------------

Objects of this type represent newly defined *functions* (usually via
the CLIPS construct) in the CLIPS subsystem. In fact the function
described above, which returns a object, corresponds to the construct.

<span>Function</span>

This represents a copy of a construct in the CLIPS subsystem, and not a
true entity. More than one object in Python can refer to the same entity
in the CLIPS subsystem.

<span>Call</span> Call this with the given arguments, if any. If one
only argument is passed and it is a , then it is considered a “list of
whitespace separated arguments[^8]” and follows the CLIPS syntax: in
order to pass a single string it has to be explicitly cast to the
*wrapper class*. Conversion to *wrapper classes* is however recommended
for all passed arguments.

\[property\]<span>Deletable</span> Verify if this can be deleted.

\[property\]<span>Module</span> Read-only property to retrieve the CLIPS
name of the where the is defined.

\[property\]<span>Name</span> Retrieve name.

<span>Next</span> Return next in the list of all CLIPS functions. is
returned at the end of the list.

<span>PPForm</span> Return the *pretty-print form* of .

<span>Remove</span> Remove this .

\[property\]<span>Watch</span> Set or retrieve debug status.

The name of this entity in CLIPS is also returned by the string coercion
function.

Generic\[pyclips-cl-Generic\]
-----------------------------

s (in CLIPS called *generic functions*) are similar to s, but they add
*generic programming* capabilities to the CLIPS system. Python
programmers will find them similar to Python functions, since
*overloading* is possible within the corresponding construct.

Each different implementation (for different argument sets) of a
*generic function* is called a , and the class provides several ways to
inspect the various s. s are identified by an *index*.

<span>Generic</span>

This represents a copy of a construct in the CLIPS subsystem, and not a
true entity. More than one objects in Python can refer to the same
entity in the CLIPS subsystem.

<span>AddMethod</span><span>restrictions, actions</span> Add a to this .
The structure of this function resembles the one of the functions: in
fact this method of actually implements the construct which is present
in CLIPS. For proper documentation of this construct, see the CLIPS
reference: the parameter (which represents the *parameter restrictions*)
must be expressed *without* parentheses; the parameter must be expressed
as in the construct, that is with all the necessary parentheses pairs.
is the index when it has to be forced (optionally). The example below
should be explanatory. can also be expressed as a sequence of tuples, in
each of which the first element is the argument name (with its proper
prefix) as a string and the following ones are the actual restrictions,
either in string form or as CLIPS primitive types – which can be
specified using *wrapper classes* types, see above.

<span>Call</span> Call this with the given arguments, if any. If one
only argument is passed and it is a , then it is considered a “list of
whitespace separated arguments” and follows the CLIPS syntax: in order
to pass a single string it has to be explicitly cast to the *wrapper
class*. Conversion to *wrapper classes* is however recommended for all
passed arguments.

\[property\]<span>Deletable</span> Verify if this can be deleted.

<span>InitialMethod</span> Return the index of first in this .

<span>MethodDeletable</span><span>midx</span> Test whether or not
specified can be deleted from this .

<span>MethodDescription</span><span>midx</span> Return the synopsis of
specified *restrictions*.

<span>MethodList</span> Return the list of indices for this .

<span>MethodPPForm</span><span>midx</span> Return the *pretty-print
form* of specified .

<span>MethodRestrictions</span><span>midx</span> Return the
*restrictions* of specified in this object: the parameter must be an or
indicating the index.

<span>MethodWatched</span><span>midx</span> Test whether or not
specified is being watched.

\[property\]<span>Module</span> Read-only property to retrieve the CLIPS
name of the where the is defined.

\[property\]<span>Name</span> Retrieve name.

<span>NextMethod</span><span>midx</span> Return the index of next in
this given the start index as an or .

<span>PPForm</span> Return the *pretty-print form* of .

<span>PrintMethods</span> Print out list for this .

<span>Remove</span> Remove this .

<span>RemoveMethod</span><span>midx</span> Remove specified from this .

<span>UnwatchMethod</span><span>midx</span> Deactivate watch on
specified .

\[property\]<span>Watch</span> Set or retrieve debug status.

<span>WatchMethod</span><span>midx</span> Activate watch on specified .

The name of this entity in CLIPS is also returned by the string coercion
function. The *factory function* for s is , which has been discussed
above.

An example for this class follows.

    >>> import clips
    >>> addf = clips.BuildGeneric("my-addf", "my generic add function")
    >>> addf.AddMethod("(?a STRING)(?b STRING)", "(str-cat ?a ?b)")
    >>> addf.AddMethod("(?a INTEGER)(?b INTEGER)", "(+ ?a ?b)")
    >>> addf.PrintMethods()
    my-addf #1  (STRING) (STRING)
    my-addf #2  (INTEGER) (INTEGER)
    For a total of 2 methods.
    >>> print addf.MethodPPForm(1)
    (defmethod MAIN::my-addf
       ((?a STRING)
        (?b STRING))
       (str-cat ?a ?b))

    >>> print addf.PPForm()
    (defgeneric MAIN::my-addf "my generic add function")

    >>> print clips.Eval('(my-addf 5 13)')
    18
    >>> print clips.Eval('(my-addf "hello,"(my-addf " " "world!"))')
    hello, world!
    >>> print clips.Eval('(my-addf "hello" 13)')
    Traceback (most recent call last):
      File "<pyshell#14>", line 1, in ?
        print clips.Eval('(my-addf "hello" 13)')
      File ".../_clips_wrap.py", line 2472, in Eval
        return _cl2py(_c.eval(expr))
    ClipsError: C10: unable to evaluate expression
    >>> s = clips.ErrorStream.Read()
    >>> print s
    [GENRCEXE1] No applicable methods for my-addf.

Please note how the *error stream* () can be used to retrieve a more
explanatory text for the error. The *error stream* can be very useful
during interactive debugging sessions to fix errors.

Class\[pyclips-cl-Class\]
-------------------------

objects are definition constructs, the most important feature of the
*COOL*[^9] sublanguage of CLIPS. As in other OOP environments, es
represent in CLIPS new data types (often resulting from aggregation of
simpler data types) which have particular ways of being handled.
Normally, as in Python, these particular ways are called *methods*[^10],
while in CLIPS they are called *message handlers*, since to apply a
method to a CLIPS object (in fact, the of a in ) a *message* has to be
sent to that object.

<span>Class</span>

This represents a copy of a construct in the CLIPS subsystem, and not a
true entity. More than one object in Python can refer to the same entity
in the CLIPS subsystem.

\[property\]<span>Abstract</span> Verify if this is *abstract* or not.

<span>AddMessageHandler</span><span>name, args, text </span> Add a new
*message handler* to this class, with specified name, body (the
argument) and argument list: this can be specified either as a sequence
of variable names or as a single string of whitespace separated variable
names. Variable names (expressed as strings) can also be *wildcard
parameters*, as specified in the . The parameter should be one of , , ,
defined at the module level: if omitted it will be considered as . The
body must be enclosed in brackets, as it is in CLIPS syntax. The
function returns the *index* of the *message handler* within this .

<span>AllMessageHandlerList</span> Return the list of constructs of this
including the ones that have been inherited from the superclass.

<span>BuildInstance</span><span>name, </span> Build an of this with the
supplied name and overriding specified . If no is specified to be
overridden, then the will assume default values.

<span>BuildSubclass</span><span>name, text </span> Build a subclass of
this with specified name and body. is the optional comment to give to
the object.

\[property\]<span>Deletable</span> Verify if this can be deleted.

<span>Description</span> Return a summary of description.

<span>InitialInstance</span> Return initial of this . It raises an error
if the has no subclass s.

<span>InitialSubclassInstance</span> Return initial instance of this
including its subclasses. It raises an error if the has no subclass s.

<span>IsSubclassOf</span><span>o</span> Test whether this is a subclass
of specified .

<span>IsSuperclassOf</span><span>o</span> Test whether this is a
superclass of specified .

<span>MessageHandlerDeletable</span><span>index</span> Return true if
specified can be deleted.

<span>MessageHandlerIndex</span><span>name </span> Find the specified ,
given its and type (as the parameter ). If type is omitted, it is
considered to be .

<span>MessageHandlerName</span><span>index</span> Return the name of
specified .

<span>MessageHandlerList</span> Return the list of constructs for this .

<span>MessageHandlerPPForm</span><span>index</span> Return the
*pretty-print form* of .

<span>MessageHandlerType</span><span>index</span> Return the type of the
specified by the provided .

<span>MessageHandlerWatched</span><span>index</span> Return watch status
of specified .

\[property\]<span>Module</span> Read-only property to retrieve the CLIPS
name of the where the is defined.

\[property\]<span>Name</span> Retrieve name.

<span>Next</span> Return next in the list of all CLIPS . is returned at
the end of the list.

<span>NextInstance</span><span>instance</span> Return next of this .
Returns if there are no s left.

<span>NextMessageHandlerIndex</span><span>index</span> Return index of
next with respect to the specified one.

<span>NextSubclassInstance</span><span>instance</span> Return next
instance of this , including subclasses. Returns if there are no s left.

<span>PPForm</span> Return the *pretty-print form* of .

<span>PreviewSend</span><span>msgname</span> Print list of s suitable
for specified message.

<span>PrintAllMessageHandlers</span> Print the list of all s for this
including the ones that have been inherited from the superclass.

<span>PrintMessageHandlers</span> Print the list of s for this .

<span>RawInstance</span><span>name</span> Create an empty of this with
specified name.

\[property\]<span>Reactive</span> Verify if this is *reactive* or not.

<span>Remove</span> Remove this .

<span>RemoveMessageHandler</span><span>index</span> Remove specified by
the provided .

\[property\]<span>Slots</span> information. This is itself an object,
having many methods, and deserves a special explaination.

<span>AllowedClasses</span><span>name</span> Return a list of allowed
class names for specified by .

<span>AllowedValues</span><span>name</span> Return a list of allowed
values for specified by .

<span>Cardinality</span><span>name</span> Return *cardinality* for
specified by .

<span>DefaultValue</span><span>name</span> Return the default value for
specified by .

<span>Exists</span><span>name</span> Return if specified by exists,
otherwise.

<span>ExistsDefined</span><span>name</span> Return if specified by is
defined in this , otherwise.

<span>Facets</span><span>name</span> Return *facet names* for specified
by .

<span>HasDirectAccess</span><span>name</span> Return if specified by is
directly accessible, otherwise.

<span>IsInitable</span><span>name</span> Return if specified by is
*initializable*, otherwise.

<span>IsPublic</span><span>name</span> Return if specified by is
*public*, otherwise.

<span>IsWritable</span><span>name</span> Return if specified by is
*writable*, otherwise.

<span>Names</span> Return the list of names.

<span>NamesDefined</span> Return the list of names explicitly defined in
this .

<span>Range</span><span>name</span> Return *numerical range information*
for specified by .

<span>Sources</span><span>name</span> Return *source class names* for
specified by .

<span>Types</span><span>name</span> Return names of *primitive types*
for specified by .

<span>Subclasses</span> Return the names of subclasses of this .

<span>Superclasses</span> Return the names of superclasses of this .

<span>UnwatchMessageHandler</span><span>index</span> Turn off debug for
specified .

\[property\]<span>WatchInstances</span> Set or retrieve debug status for
this s.

<span>WatchMessageHandler</span><span>index</span> Turn on debug for
specified .

\[property\]<span>WatchSlots</span> Set or retrieve debug status.

The name of this entity in CLIPS is also returned by the string coercion
function. The *factory function* for es is , which has been discussed
above.

Instance\[pyclips-cl-Instance\]
-------------------------------

objects represent *class instances* (that is, *objects* in the OOP
paradigm) that live in the CLIPS subsystem. Messages can be sent to
those objects and values can be set and retrieved for the *slots*
defined in the related *class*, where the meaning of has been described
in the section above.

<span>Instance</span>

This represents a copy of an object in the CLIPS subsystem, and not a
true entity. More than one object in Python can refer to the same entity
in the CLIPS subsystem.

\[property\]<span>Class</span> Retrieve the of this : this property
actually refers to a object, so all of its methods are available.

<span>DirectRemove</span> Directly remove this , without sending a
message.

<span>GetSlot</span><span>slotname</span> Retrieve the value of
specified as argument. The synonym is retained for readability and
compatibility. Please notice that these functions are provided in order
to be more coherent with the behaviour of CLIPS API, as CLIPS C
interface users know that a function like usually bypasses message
passing, thus accessing directly. The possibilities offered by are also
accessible using the property described below.

<span>IsValid</span> Determine if this is still valid.

\[property\]<span>Name</span> Retrieve the name.

<span>Next</span> Return next in the list of all CLIPS . It returns if
there are no s left.

<span>PPForm</span> Return the *pretty-print form* of .

<span>PutSlot</span><span>slotname, value</span> Set the value of
specified . The parameter should contain a value of the correct type, if
necessary cast to one of the *wrapper classes* described above if the
type could be ambiguous. The synonym is provided for readability and
compatibility. What has been said about also yields for the hereby
described function, as the possibilities offered by are also accessible
using the property described below.

<span>Remove</span> Remove this (passing a message).

<span>Send</span><span>msg </span> Send the provided *message* with the
given arguments to . The parameter (that is, *message arguments*),
should be a string containing a list of arguments separated by
whitespace, a tuple containing the desired arguments or a value of a
basic type. Also in the second case the tuple elements have to be of
basic types. The function returns a value depending on the passed
message.

\[property\]<span>Slots</span> Dictionary of . This member *behaves*
like a , but is not related to such objects. In fact, the values of are
accessible using a -like syntax (square brackets), but not all the
members of are implemented. The functionality of and is superseded by
this property.

The name of this entity in CLIPS is also returned by the string coercion
function. The *factory function* for s is , which has been discussed
above.

Here is an example of usage of and objects:

    >>> import clips
    >>> clips.Build("""(defclass TEST1
        (is-a USER)
        (slot ts1 (type INSTANCE-NAME))
        (multislot ts2))""")
    >>> c = clips.FindClass("TEST1")
    >>> print c.PPForm()
    (defclass MAIN::TEST1
       (is-a USER)
       (slot ts1
          (type INSTANCE-NAME))
       (multislot ts2))

    >>> clips.Reset()
    >>> i = clips.BuildInstance("test1", c)
    >>> i.Slots['ts2'] = clips.Multifield(['hi', 'there'])
    >>> i.Slots['ts1'] = i.Name
    >>> print i.PPForm()
    [test1] of TEST1 (ts1 [test1]) (ts2 "hi" "there")

Definstances\[pyclips-cl-Definstances\]
---------------------------------------

As there are for objects, are supported in CLIPS by the construct: it
allows certain default s to be created each time a is issued. In this
construct is provided via the class.

<span>Definstances</span>

This represents a copy of the construct in the CLIPS subsystem, and not
a true entity. More than one object in Python can refer to the same
entity in the CLIPS subsystem.

\[property\]<span>Deletable</span> Verify if this can be deleted.

\[property\]<span>Module</span> Read-only property to retrieve the CLIPS
name of the where the is defined.

\[property\]<span>Name</span> Retrieve name.

<span>Next</span> Return next in the list of all CLIPS . is returned at
the end of the list.

<span>PPForm</span> Return the *pretty-print form* of this object.

<span>Remove</span> Delete this object from CLIPS subsystem.

The name of this entity in CLIPS is also returned by the string coercion
function. The *factory function* for is , which has been discussed
above.

Module\[pyclips-cl-Module\]
---------------------------

s are a way, in CLIPS, to organize constructs, facts and objects. There
is a big difference between *modules* and *environments*[^11]: one
should think of a as a *group* of definitions and objects, which can
interoperate with entities that are defined in other s. The class
provides methods, similar to the ones defined at top level, to directly
create entities as part of the itself, as well as methods to examine
contents. Also, objects have methods that instruct the related CLIPS to
become *current*, so that certain operations can be performed without
specifying the to which they have to be applied.

<span>Module</span>

This represents a copy of a construct in the CLIPS subsystem, and not a
true entity. More than one object in Python can refer to the same entity
in the CLIPS subsystem.

\[property\]<span>Name</span> Return the name of this .

<span>Next</span> Return next in the list of all CLIPS . is returned at
the end of the list.

<span>PPForm</span> Return the *pretty-print form* of this .

<span>SetCurrent</span> Make the that this object refers the current .

<span>SetFocus</span> Set focus to this .

For the following methods:

    TemplateList(), FactList(), DeffactsList(), ClassList(), DefinstancesList(),
    GenericList(), FunctionList(), GlobalList(), BuildTemplate(),
    BuildDeffacts(), BuildClass(), BuildDefinstances(), BuildGeneric(),
    BuildFunction(), BuildGlobal(), BuildRule(), BuildInstance(),
    PrintTemplates(), PrintDeffacts(), PrintRules(), PrintClasses(),
    PrintInstances(), PrintSubclassInstances(), PrintDefinstances(),
    PrintGenerics(), PrintFunctions(), PrintGlobals(), ShowGlobals(),
    PrintAgenda(), PrintBreakpoints(), ReorderAgenda(), RefreshAgenda()

please refer to the corresponding function defined at module level,
keeping in mind that these methods perform the same task but within the
where they are executed.

The name of this entity in CLIPS is also returned by the string coercion
function. The *factory function* for s is , which has been discussed
above.

Environment\[pyclips-cl-Environment\]
-------------------------------------

This class represents an *environment*, and implements almost all the
module level functions and classes. The only objects appearing at level
and *not* at level are the CLIPS I/O subsystem *streams*, which are
shared with the rest of the CLIPS engine.

objects are not a feature of CLIPS sessions (as stated above), thus
there is no way to identify them in CLIPS using a *symbol*. So objects
do not have a property. Instead, CLIPS provides a way to identify an
*environment* through an integer called *index*.

<span>Environment</span>

Please refer to top level functions, variables and classes for
information on contents of objects. The extra methods and properties
follow below.

\[property\]<span>Index</span> Retrieve the *index* identifying this
internally in CLIPS.

<span>SetCurrent</span> Make the *environment* that this object refers
the current .

Further explanations about objects can be found in the appendices.

Status and Configuration Objects\[pyclips-cl-statusconf\]
---------------------------------------------------------

As seen in the introduction, there are a couple of objects that can be
accessed to configure the underlying CLIPS engine and to retrieve its
status. These are the and objects. The reason why configuration and
status functions have been grouped in these objects is only cosmetic: in
fact there is no counterpart of and in CLIPS. It was seen as convenient
to group configuration and debug functions in two main objects and to
make them accessible mainly as *properties* in Python, instead of
populating the module namespace with too many *get/set* functions.

There is also an object, called , which gives information about memory
utilization and allow the user to attempt to free memory used by the
CLIPS engine and no longer needed.

A description of what the above objects (which can not be instanced by
the user of [^12]) actually expose follows.

### Engine Configuration\[pyclips-cl-statusconf-engine\]

The object allows the configuration of some features of the underlying
CLIPS engine. Here are the properies provided by :

\[property\]<span>AutoFloatDividend</span> Reflects the behaviour of
CLIPS . When the dividend is always considered to be a floating point
number within divisions.

\[property\]<span>ClassDefaultsMode</span> Reflects the behaviour of
CLIPS . Possible values of this flag are and . See for details.

\[property\]<span>DynamicConstraintChecking</span> Reflects the
behaviour of CLIPS . When , *function calls* and *constructs* are
checked against constraint violations.

\[property\]<span>FactDuplication</span> Reflects the behaviour of CLIPS
. When , can be reasserted when they have already been asserted[^13].

\[property\]<span>IncrementalReset</span> Reflects the behaviour of
CLIPS . When newly defined are updated according to current , otherwise
new will only be updated by defined after their construction.

\[property\]<span>ResetGlobals</span> Reflects the behaviour of CLIPS .
When the variables are reset to their initial value after a call to .

\[property\]<span>SalienceEvaluation</span> Reflects the behaviour of
CLIPS . Can be one of , , . See the previous chapter and for more
information.

\[property\]<span>SequenceOperatorRecognition</span> Reflects the
behaviour of CLIPS . When , values in function calls are treated as a
single argument.

\[property\]<span>StaticConstraintChecking</span> Reflects the behaviour
of CLIPS . When , *slot values* are checked against constraint
violations.

\[property\]<span>Strategy</span> Reflects behaviour. Can be any of the
following values: , , , , , or . See the previous chapter and for more
information.

### Debug Settings\[pyclips-cl-statusconf-debug\]

The object provides access to the debugging and trace features of CLIPS.
During a CLIPS interactive session debug and trace messages are printed
on the system console (which maps the I/O *router*). Users of the trace
systems will have to poll the to read the generated messages.

In CLIPS, the process of enabling trace features on some class of
entities is called *to watch* such a class; this naming convention is
reflected in . Note that specific objects can be *watched*: many classes
have their own property to enable or disable debugging on a particular
object.

Also, CLIPS provides a facility to log all debug information to physical
files: this is called *to dribble* on a file. *Dribbling* is possible
from via the appropriate methods.

The names of methods and properties provided by this object are quite
similar to the corresponding commands in CLIPS, so more information
about debugging features can be found in .

\[property\]<span>ActivationsWatched</span> Flag to enable or disable
trace of activations and deactivations.

\[property\]<span>CompilationsWatched</span> Flag to enable or disable
trace of construct definition progress.

<span>DribbleActive</span> Tell whether or not *dribble* is active.

<span>DribbleOff</span> Turn off *dribble* and close the *dribble* file.

<span>DribbleOn</span><span>fn</span> Enable *dribble* on the file
identified by provided filename .

\[property\]<span>ExternalTraceback</span> Flag to enable or disable
printing traceback messages to Python if an error occurs when the CLIPS
engine calls a Python function. Please note that the error is not
propagated to the Python interpreter. See the appendices for a more
detailed explaination.

\[property\]<span>FactsWatched</span> Flag to enable or disable trace of
assertions and retractions.

\[property\]<span>FunctionsWatched</span> Flag to enable or disable
trace of start and finish of .

\[property\]<span>GenericFunctionsWatched</span> Flag to enable or
disable trace of start and finish of functions.

\[property\]<span>GlobalsWatched</span> Flag to enable or disable trace
of assignments to variables.

\[property\]<span>MethodsWatched</span> Flag to enable or disable trace
of start and finish of within functions.

\[property\]<span>MessageHandlersWatched</span> Flag to enable or
disable trace of start and finish of .

\[property\]<span>MessagesWatched</span> Flag to enable or disable trace
of start and finish of *messages*.

\[property\]<span>RulesWatched</span> Flag to enable or disable trace of
firings.

\[property\]<span>SlotsWatched</span> Flag to enable or disable trace of
changes to .

\[property\]<span>StatisticsWatched</span> Flag to enable or disable
reports about timings, number of and , and other information after has
been performed.

<span>UnwatchAll</span> Turn off *watch* for all items above.

<span>WatchAll</span> *Watch* all items above.

### Memory Operations\[pyclips-cl-statusconf-memory\]

This object provides access to the memory management utilities of the
underlying CLIPS engine. As said above, it allows the reporting of
memory usage and the attempt to free memory that is used not for
computational purposes. Also, a property of this object affects the
engine behaviour about whether or not to cache some information. Here is
what the object exposes:

\[property\]<span>Conserve</span> When set to , the engine does not
cache *pretty-print forms* to memory, thus being more conservative.

\[property\]<span>EnvironmentErrorsEnabled</span> When set to , the
engine is enabled to directly write fatal environment errors to the
console (). This kind of messages is in most of the cases printed when
the program exits, so it can be annoying. The behaviour is disabled by
default.

<span>Free</span> Attempt to free as much memory as possible of the one
used by the underlying CLIPS engine for previous computations.

\[property\]<span>PPBufferSize</span> Report the size (in bytes) of the
buffers used by to return *pretty-print forms* or similar values. By
default this is set to 8192, but the user can modify it using values
greater than or equal to 256. Greater values than the default can be
useful when such forms are used to reconstruct CLIPS entities and
definitions are so complex that the default buffer size is insufficient.

\[property\]<span>Requests</span> Read-only property reporting the
number of memory request made by the engine to the operating system
since has been initialized.

\[property\]<span>Used</span> Read-only property reporting the amount,
in kilobytes, of memory used by the underlying CLIPS engine.

\[property\]<span>NumberOfEnvironments</span> Read-only property
reporting the number of currently allocated s.

I/O Streams\[pyclips-cl-iostreams\]
-----------------------------------

In order to be more embeddable, CLIPS defines a clear way to redirect
its messages to locations where they can be easily retrieved. CLIPS
users can access these locations for reading or writing by specifying
them as *logical names* (namely , , , , , , , )[^14]. creates some
special unique objects[^15], called *I/O streams* throughout this
document, to allow the user to read messages provided by the underlying
engine. Most of these objects have only one method, called , that
consumes CLIPS output and returns it as a string: this string contains
all output since a previous call or module initialization. The only
exception is whose single method is and it accepts a string[^16] as
parameter. As CLIPS writes line-by-line, the string resulting from a
call to can contain newline characters, often indicating subsequent
messages.

Here is a list of the *I/O streams* provided by , along with a brief
description of each.

<span>l|l</span><span>var</span><span>Stream</span><span>Description</span>

Some of the provided *I/O streams* are actually not so relevant for
programmers: for instance, it is of little use to read the contents of
and . In the latter case, in fact, there are other inspection functions
that provide the same information in a more structured way than text.
However they are available to provide a closer representation of the
programming interface and allow CLIPS programmers to verify if the
output of *CLIPS-oriented* calls (see the paragraph about and in the
appendices) really do what they are expected to.

Predefined es\[pyclips-cl-stockclasses\]
----------------------------------------

defines[^17], some objects, that is the ones that are present in CLIPS
itself by default. They are defined in order to provide a compact access
to CLIPS “stock” classes: most of these objects are of little or no use
generally (although they can be handy when testing for class
specification or generalization), but at least one () can be used to
make code more readable.

Namely, these es are:

<span>l|l</span><span>var</span><span>Python Name</span><span>CLIPS
defclass</span>

The following code, shows how to use the “traditional” factory function
and how to directly subclass one of the predefined object. In the latter
case, probably, the action of subclassing is expressed in a more clear
way:

    >>> import clips
    >>> C = clips.BuildClass("C", "(is-a USER)(slot s)")
    >>> print C.PPForm()
    (defclass MAIN::C
       (is-a USER)
       (slot s))

    >>> D = clips.USER_CLASS.BuildSubclass("D", "(slot s)")
    >>> print D.PPForm()
    (defclass MAIN::D
       (is-a USER)
       (slot s))

Although it actually does not save typing (the statement is slightly
longer), the second form can be used to produce more readable Python
code.

[^1]: In this is different from as only the empty string evaluates to
    false in Python. However, it seemed closer to the assumption that
    symbols in CLIPS are not to be considered as “*literals*” (they are
    more similar to implicitly defined variables) to implement such
    behaviour, that can be reverted with an explicit conversion to .

[^2]: CLIPS stores its objects (or entities) in ordered lists, so it
    makes sense to “iterate” over these lists. However this
    implementation of does not implement *iterators* (as known in
    Python) on these classes: a way to do this is currently under
    examination.

[^3]: Actually *pretty-print forms* use fixed size buffers to build the
    representing string: when such a form is too complex, the default
    buffer size of 8192 bytes can be insufficient. In this case the
    *PPBufferSize* property of the *Memory* object can be used to allow
    the creation of properly sized buffers.

[^4]: Actually, the main rule is that if a has been ed then it is
    read-only. Note that all *shadow representations* of CLIPS asserted
    entities are read-only.

[^5]: This is also not always true: as said before, there is no way to s
    that have named slots using a string if there is not a for this kind
    of . However, once a with the specified slots has been created, this
    becomes possible.

[^6]: The authors of CLIPS call a *relation* the first field of the
    itself, although it is not needed to actually represent a real
    relationship.

[^7]: *Salience* is a value that represents the *priority* of a in
    CLIPS.

[^8]: See the syntax for the toplevel function with the same name.

[^9]: Acronym for CLIPS Object-Oriented Language.

[^10]: Note that the term has been used for function overloading in the
    definition of functions.

[^11]: Besides the discussion above, also notice that in a “pure” CLIPS
    session there is no concept of *environment* at all: the use of
    environment is reserved to those who embed CLIPS in another program,
    such as users.

[^12]: Besides removal of class definitions, a *singleton*-styled
    implementation mechanism prevents the user from creating further
    instances of the objects.

[^13]: This does not change the behaviour of the class, which prohibits
    reassertion anyway. However, that would be asserted through firing
    of rules and would generate duplications will not raise an error
    when this behaviour is set.

[^14]: CLIPS also defines as a *logical name*: as stated in this
    indicates in functions that read text and in function that print
    out. In , for all functions that print out to the user must read
    from *StdoutStream*.

[^15]: in fact defines one more I/O stream, called , which is used
    internally to retrieve output from CLIPS that shouldn’t go anywhere
    else. users however are not supposed to interact with this object.

[^16]: The current implementation converts the argument to a string, so
    other types can be accepted.

[^17]: At the module level only: defining these objects at the
    *environment* level could cause aliasing current CLIPS enviroment.
    On the other hand, if these objects were implemented in a way that
    checked for aliasing, access to the actual entities would be surely
    slower only favouring compactness of user code.
